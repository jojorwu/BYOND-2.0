# Virtual Machine (VM) Internals

The Virtual Machine (VM) is the heart of the BYOND 2.0 engine. It is a stack-based, cooperatively multitasked virtual machine responsible for executing the compiled DM bytecode that defines all game logic. The VM is designed for high performance, reliability, and safe script execution.

## Key Components

### 1. DreamThread

A `DreamThread` is the primary component responsible for executing bytecode. Each `DreamThread` represents a single, independent thread of execution within the VM, similar to an operating system thread but managed by the engine's scheduler.

*   **Call Stack (`Stack<CallFrame>`):** Each thread has its own call stack, which stores `CallFrame` structs. A `CallFrame` is a lightweight structure that contains essential information about the currently executing procedure:
    *   `PC` (Program Counter): An integer that points to the next instruction to be executed in the procedure's bytecode.
    *   `StackBase`: An integer that points to the base of the current procedure's frame on the value stack. This allows for efficient access to local variables and arguments.
*   **Value Stack (`List<DreamValue>`):** This is a dynamically sized list that serves as the working memory for the thread. All values—local variables, arguments, return values, and intermediate results of calculations—are pushed onto and popped from this stack. Using a `List` instead of a `Stack` allows for indexed access, which is crucial for retrieving locals and arguments relative to the `StackBase`.

### 2. Bytecode and Opcodes

The VM executes bytecode generated by the OpenDream compiler from `.dme` and `.dm` source files. This bytecode is a portable, intermediate representation of the game logic.

*   **Opcodes:** The bytecode consists of a sequence of instructions called opcodes. Each opcode is a single byte that corresponds to a specific operation, such as:
    *   `PushString`, `PushFloat`: Push a constant value onto the value stack.
    *   `Add`, `Subtract`: Perform arithmetic operations on the top two values of the stack.
    *   `Call`: Invoke another procedure.
    *   `Jump`, `JumpIfFalse`: Control the flow of execution.
*   **Opcode Dispatch:** The core of the `DreamThread` is its execution loop, which uses a large `switch` statement to dispatch opcodes. This is a highly efficient mechanism that allows the JIT compiler to optimize the dispatch into a jump table.

### 3. DreamValue

`DreamValue` is a universal value type (a `struct`) used to represent all DM data types, including numbers, strings, objects, and types. This struct-based, discriminated union approach allows the VM to handle different data types in a type-safe and efficient manner without the overhead of boxing for simple types like floats.

## Execution Lifecycle

1.  **Loading (`DreamMakerLoader`):** When scripts are loaded, the `DreamMakerLoader` service reads the JSON output from the compiler. It populates the `DreamVM` with procedure definitions (`DreamProc`) and object type information (`ObjectType`), making them ready for execution.
2.  **Thread Creation:** To execute a procedure (e.g., the entry point `world.New()`), a new `DreamThread` is created by the `ScriptManager`. The thread is initialized with a `CallFrame` for the target procedure.
3.  **Execution Loop (`DreamThread.Run`)**: The `ScriptHost`'s scheduler calls the `Run` method on the thread, providing a time budget for the current tick. The thread enters its main loop:
    a.  It reads the next opcode from the bytecode stream.
    b.  It uses the `switch` statement to jump to the handler for that opcode.
    c.  The handler performs its operation (e.g., manipulating the value stack, changing the `PC`).
    d.  The loop continues until the time budget is exhausted, the procedure returns, or the thread finishes execution.
4.  **Cooperative Multitasking:** The `ScriptHost` uses a scheduler that manages all active `DreamThread`s. On each game tick, the scheduler runs each thread for a small time slice. If a thread's work is not complete, its state is preserved, and it will be resumed on a subsequent tick. This cooperative model ensures server responsiveness and prevents any single long-running script from freezing the entire game.
