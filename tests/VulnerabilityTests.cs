using NUnit.Framework;
using Shared;
using System.IO;
using System;
using Core.VM.Runtime;
using Core.VM;
using Core.VM.Procs;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using System.Collections.Generic;

namespace tests
{
    [TestFixture]
    public class VulnerabilityTests
    {
        [Test]
        public void PathSanitizer_Vulnerability_Reproduction()
        {
            // Setup a project structure
            var tempDir = Path.Combine(Path.GetTempPath(), "OpenDreamVulnerabilityTest_" + Guid.NewGuid().ToString());
            var projectDir = Path.Combine(tempDir, "mygame");
            var scriptsDir = Path.Combine(projectDir, "scripts");
            var secretDir = Path.Combine(projectDir, "scripts_secret");

            Directory.CreateDirectory(scriptsDir);
            Directory.CreateDirectory(secretDir);

            var secretFile = Path.Combine(secretDir, "secret.txt");
            File.WriteAllText(secretFile, "CONFIDENTIAL DATA");

            var project = new Core.Project(projectDir);

            // maliciousPath is relative to the project root, but targeted to bypass the scripts folder check
            var maliciousPath = "scripts_secret/secret.txt";

            Console.WriteLine($"Full Root Path: {Path.GetFullPath(project.GetFullPath("scripts"))}");
            Console.WriteLine($"Full User Path: {Path.GetFullPath(project.GetFullPath(maliciousPath))}");

            Assert.Throws<System.Security.SecurityException>(() => {
                PathSanitizer.Sanitize(project, maliciousPath, "scripts");
            }, "PathSanitizer should have blocked access to sibling directory with same prefix.");

            Directory.Delete(tempDir, true);
        }

        [Test]
        public void CallStatement_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.CallStatement);
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void Call_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.Call);
            bytecode.Add((byte)DMReference.Type.GlobalProc);
            bytecode.AddRange(BitConverter.GetBytes(0)); // Global proc index 0
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.AddRange(BitConverter.GetBytes(0)); // unused
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void LocalAccess_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            // localVariableCount = 1, but we try to access index 5
            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushReferenceValue);
            bytecode.Add((byte)DMReference.Type.Local);
            bytecode.Add(5); // Index 5
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 1);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void ArgumentAccess_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            // 0 arguments, but we try to access index 0
            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushReferenceValue);
            bytecode.Add((byte)DMReference.Type.Argument);
            bytecode.Add(0); // Index 0
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void StringPool_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());
            vm.Context.Strings.Clear(); // No strings in the pool

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushString);
            bytecode.AddRange(BitConverter.GetBytes(0)); // Try to access string ID 0
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void DereferenceCall_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.DereferenceCall);
            bytecode.AddRange(BitConverter.GetBytes(0)); // stringId 0
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }
    }
}
