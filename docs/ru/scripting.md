# Скриптинг

Игровой движок BYOND 2.0 предлагает полиглотную среду для написания скриптов. Хотя **DM (Dream Maker)** является основным языком, **Lua** и **C#** также поддерживаются для специализированных случаев.

## Рекомендации по выбору языка

*   **DM:** Рекомендуется для всей основной игровой логики. Его синтаксис специально разработан для определения игровых объектов и взаимодействий.
*   **Lua:** Идеально подходит для динамических сценариев, быстрого прототипирования или реализации сложного поведения ИИ, где его легковесность является преимуществом.
*   **C#:** Лучший выбор для критически важных по производительности систем, сложной обработки данных или интеграции с внешними .NET библиотеками.

## DM (Dream Maker)

DM — это нативный язык платформы BYOND. Движок использует компилятор OpenDream для преобразования `.dm` файлов в байт-код, исполняемый `DreamVM`.

*   **Исполнение:** Выполняется высокопроизводительной `DreamVM`, стековой виртуальной машиной.
*   **Точка входа:** Сервер автоматически выполняет процедуру `/world/New()` при создании игрового мира.

### Пример DM

Этот пример показывает объект игрока, который записывает сообщение в мировой лог при получении урона, демонстрируя взаимодействие с основным API.

```dm
// scripts/player.dm
/obj/creature/player
    var/hp = 100

    proc/TakeDamage(amount)
        hp -= amount
        world.log << "[src] получил [amount] урона! Осталось [hp] HP."
        if (hp <= 0)
            del src
```

## Lua

Lua — это легковесный и гибкий язык для написания скриптов, интегрированный с помощью библиотеки NLua.

*   **Доступ к API:** Скрипты Lua могут получать доступ к API движка через глобальный объект `GameApi`.
*   **Точка входа:** Сервер выполняет функцию `main()` в файле `scripts/main.lua` при запуске.

### Пример Lua API

Этот пример демонстрирует более сложную задачу: поиск всех объектов игроков и выдача им "зелья лечения".

```lua
-- scripts/main.lua
function main()
    local objectApi = global.GameApi.ObjectApi
    local players = objectApi:GetObjects("/obj/creature/player")

    for i, player in ipairs(players) do
        local potion = objectApi:CreateObject("/obj/item/potion/healing")
        potion:SetProperty("x", player:GetProperty("x"))
        potion:SetProperty("y", player:GetProperty("y"))
        print("Выдал зелье лечения игроку "..tostring(player.Id))
    end
end
```

## C#

Скриптинг на C# предлагает высочайшую производительность, используя Roslyn для компиляции "на лету".

*   **Доступ к API:** Точки входа в скриптах C# получают экземпляр `IGameApi`.
*   **Точка входа:** Сервер ищет статический метод `Main(IGameApi gameApi)` в любом классе внутри `.cs` файлов в каталоге `scripts`.

### Пример C# API

Этот пример демонстрирует задачу, ориентированную на производительность: вычисление среднего здоровья всех игроков с использованием LINQ из библиотеки .NET.

```csharp
// scripts/health_checker.cs
using System.Linq;
using BYOND2.Core.Api;
using BYOND2.Shared.GameObjects;

public class HealthChecker
{
    public static void Main(IGameApi gameApi)
    {
        var players = gameApi.ObjectApi.GetObjects("/obj/creature/player");
        if (!players.Any()) return;

        double averageHp = players.Average(p => (double)p.GetProperty("hp"));

        gameApi.WorldApi.Log($"Среднее HP игроков: {averageHp:F2}");
    }
}
```

## Горячая перезагрузка

Все три системы скриптинга поддерживают горячую перезагрузку. Сервер отслеживает изменения в файлах в каталоге `scripts` и автоматически перезагружает их, что позволяет вносить изменения в игровую логику в реальном времени без перезапуска сервера.
