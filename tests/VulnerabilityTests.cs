using NUnit.Framework;
using Shared;
using System.IO;
using System;
using Core.VM.Runtime;
using Core.VM;
using Core.VM.Procs;
using Core.Objects;
using Core.Api;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using System.Collections.Generic;
using Moq;

namespace tests
{
    [TestFixture]
    public class VulnerabilityTests
    {
        [Test]
        public void PathSanitizer_Vulnerability_Reproduction()
        {
            // Setup a project structure
            var tempDir = Path.Combine(Path.GetTempPath(), "OpenDreamVulnerabilityTest_" + Guid.NewGuid().ToString());
            var projectDir = Path.Combine(tempDir, "mygame");
            var scriptsDir = Path.Combine(projectDir, "scripts");
            var secretDir = Path.Combine(projectDir, "scripts_secret");

            Directory.CreateDirectory(scriptsDir);
            Directory.CreateDirectory(secretDir);

            var secretFile = Path.Combine(secretDir, "secret.txt");
            File.WriteAllText(secretFile, "CONFIDENTIAL DATA");

            var project = new Core.Project(projectDir);

            // maliciousPath is relative to the project root, but targeted to bypass the scripts folder check
            var maliciousPath = "scripts_secret/secret.txt";

            Console.WriteLine($"Full Root Path: {Path.GetFullPath(project.GetFullPath("scripts"))}");
            Console.WriteLine($"Full User Path: {Path.GetFullPath(project.GetFullPath(maliciousPath))}");

            Assert.Throws<System.Security.SecurityException>(() => {
                PathSanitizer.Sanitize(project, maliciousPath, "scripts");
            }, "PathSanitizer should have blocked access to sibling directory with same prefix.");

            Directory.Delete(tempDir, true);
        }

        [Test]
        public void CallStatement_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.CallStatement);
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void Call_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.Call);
            bytecode.Add((byte)DMReference.Type.GlobalProc);
            bytecode.AddRange(BitConverter.GetBytes(0)); // Global proc index 0
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.AddRange(BitConverter.GetBytes(0)); // unused
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void LocalAccess_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            // localVariableCount = 1, but we try to access index 5
            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushReferenceValue);
            bytecode.Add((byte)DMReference.Type.Local);
            bytecode.Add(5); // Index 5
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 1);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void ArgumentAccess_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            // 0 arguments, but we try to access index 0
            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushReferenceValue);
            bytecode.Add((byte)DMReference.Type.Argument);
            bytecode.Add(0); // Index 0
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void StringPool_OutOfBounds_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());
            vm.Context.Strings.Clear(); // No strings in the pool

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PushString);
            bytecode.AddRange(BitConverter.GetBytes(0)); // Try to access string ID 0
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void DereferenceCall_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.DereferenceCall);
            bytecode.AddRange(BitConverter.GetBytes(0)); // stringId 0
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(1000000)); // Huge argStackDelta
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void CreateList_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.CreateList);
            bytecode.AddRange(BitConverter.GetBytes(100)); // Size 100
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void PickUnweighted_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.PickUnweighted);
            bytecode.AddRange(BitConverter.GetBytes(100)); // Count 100
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void SetGlobal_MemoryExhaustion_Reproduction()
        {
            var context = new DreamVMContext();

            // Try to set global at a huge index
            context.SetGlobal(2000000, new DreamValue(123f));

            // Should be ignored due to MaxGlobals limit
            Assert.That(context.Globals.Count, Is.LessThan(2000000));
        }

        [Test]
        public void Range_DistanceSanitization_Test()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, new INativeProcProvider[] { new StandardNativeProcProvider() });
            vm.Initialize();

            var stdLibMock = new Mock<IStandardLibraryApi>();
            int capturedDist = -1;
            stdLibMock.Setup(m => m.Range(It.IsAny<int>(), It.IsAny<int>(), It.IsAny<int>(), It.IsAny<int>()))
                      .Callback<int, int, int, int>((d, x, y, z) => capturedDist = d)
                      .Returns(new List<GameObject>());

            var gameApiMock = new Mock<IGameApi>();
            gameApiMock.Setup(m => m.StdLib).Returns(stdLibMock.Object);
            vm.Context.GameApi = gameApiMock.Object;

            var rangeProc = (NativeProc)vm.Context.Procs["range"];

            // distance = 1000000, should be clamped to 100
            var thread = new DreamThread(new DreamProc("test", Array.Empty<byte>(), Array.Empty<string>(), 0), vm.Context, 100);
            rangeProc.Call(thread, null, new[] { new DreamValue(1000000f), new DreamValue(0f), new DreamValue(0f), new DreamValue(0f) });

            Assert.That(capturedDist, Is.EqualTo(100));

            // distance = -50, should be clamped to 0
            rangeProc.Call(thread, null, new[] { new DreamValue(-50f), new DreamValue(0f), new DreamValue(0f), new DreamValue(0f) });
            Assert.That(capturedDist, Is.EqualTo(0));
        }

        [Test]
        public void InfiniteRecursion_RecursionLimit_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            // Proc that calls itself:
            // 0: Call(GlobalProc(0), None, 0, 0)
            // 11: Return
            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.Call);
            bytecode.Add((byte)DMReference.Type.GlobalProc);
            bytecode.AddRange(BitConverter.GetBytes(0)); // self index 0
            bytecode.Add((byte)DMCallArgumentsType.None);
            bytecode.AddRange(BitConverter.GetBytes(0)); // 0 args
            bytecode.AddRange(BitConverter.GetBytes(0)); // unused
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("infinite_recursion", bytecode.ToArray(), Array.Empty<string>(), 0);
            vm.Context.AllProcs.Add(proc);
            vm.Context.Procs["infinite_recursion"] = proc;

            var thread = new DreamThread(proc, vm.Context, 10000); // High instruction limit

            thread.Run(10000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }

        [Test]
        public void MassConcatenation_StackUnderflow_Reproduction()
        {
            var vm = new DreamVM(Options.Create(new ServerSettings()), NullLogger<DreamVM>.Instance, Array.Empty<INativeProcProvider>());

            var bytecode = new List<byte>();
            bytecode.Add((byte)Opcode.MassConcatenation);
            bytecode.AddRange(BitConverter.GetBytes(100)); // Count 100
            bytecode.Add((byte)Opcode.Return);

            var proc = new DreamProc("vulnerable_proc", bytecode.ToArray(), Array.Empty<string>(), 0);
            var thread = new DreamThread(proc, vm.Context, 1000);

            thread.Run(1000);
            Assert.That(thread.State, Is.EqualTo(DreamThreadState.Error));
        }
    }
}
