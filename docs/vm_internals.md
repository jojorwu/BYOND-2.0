# Внутреннее устройство виртуальной машины (VM)

Виртуальная машина (ВМ) является сердцем движка BYOND-2.0, отвечая за исполнение скомпилированного игрового кода. Это стековая ВМ, которая исполняет кастомный байт-код, сгенерированный компилятором.

## Ключевые концепции

### Стековая архитектура

ВМ использует два основных стека для своей работы:

1.  **Стек значений (`Value Stack`):** Основной стек, используемый для выполнения опкодов. Все операции (арифметические, логические и т.д.) берут свои операнды с вершины этого стека и помещают на него результат. Этот стек также используется для передачи аргументов в процедуры.
2.  **Стек вызовов (`Call Stack`):** Этот стек отслеживает активные вызовы процедур. Каждый раз, когда вызывается процедура, на вершину стека вызовов помещается новый **стековый фрейм (`Call Frame`)**.

### Стековые фреймы (`Call Frames`)

Каждый `CallFrame` содержит информацию, необходимую для выполнения одной процедуры:

-   `DreamProc`: Ссылка на саму исполняемую процедуру (которая содержит байт-код).
-   `PC` (Program Counter): Счетчик команд, указывающий на текущую исполняемую инструкцию в байт-коде.
-   `StackBase`: Указатель (индекс) на стек значений, который отмечает начало стекового фрейма данной процедуры. Это позволяет эффективно получать доступ к аргументам и локальным переменным.

## Процесс исполнения

### Вызов процедуры (`Call`)

1.  **Подготовка:** Перед вызовом опкода `Call` все аргументы для процедуры помещаются на стек значений. Затем на стек помещается ссылка на саму процедуру (`DreamProc`).
2.  **Исполнение `Call`:**
    - Опкод `Call` считывает свой операнд — количество переданных аргументов.
    - Он снимает `DreamProc` со стека.
    - Вычисляется `StackBase` для нового фрейма: `StackBase = Stack.Count - argCount`.
    - Создается новый `CallFrame` с `DreamProc` и `StackBase`.
    - `CallFrame` помещается на стек вызовов.
    - На стек значений помещаются `null` значения для всех локальных переменных процедуры.
3.  **Исполнение:** Основной цикл ВМ теперь берет `PC` и `Proc` из верхнего `CallFrame` в стеке вызовов и исполняет байт-код.

### Доступ к переменным

-   **Аргументы:** Доступ к аргументам осуществляется по индексу относительно `StackBase`. Например, `PushArgument 0` поместит на стек первый аргумент (`Stack[StackBase + 0]`).
-   **Локальные переменные:** Доступ к локальным переменным осуществляется со смещением, равным количеству аргументов: `PushLocal 0` поместит на стек первую локальную переменную (`Stack[StackBase + Proc.ArgumentCount + 0]`).

### Возврат из процедуры (`Return`)

1.  **Исполнение `Return`:**
    - Снимается `CallFrame` с вершины стека вызовов.
    - Снимается возвращаемое значение с вершины стека значений.
    - Со стека значений удаляются все локальные переменные и аргументы текущей процедуры (все, что находится от `StackBase` до вершины).
    - Возвращаемое значение помещается обратно на вершину стека.
2.  **Продолжение:** ВМ продолжает исполнение с `PC` из нового верхнего `CallFrame` в стеке вызовов. Если стек вызовов пуст, исполнение потока завершается.
